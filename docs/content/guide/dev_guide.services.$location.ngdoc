@ngdoc overview
@name Developer Guide: Angular のサービス : $location を使う
@description

# 何をしてくれるのか?

`$location` サービスは、 ({@link https://developer.mozilla.org/en/window.location window.location}
をもとに) ブラウザのアドレスバーの URL をパースし、アプリケーションで URL 
を利用できるようにしてくれます。
アドレスバーの URL に変更があれば、 $location サービスに反映され、
さらに $location への変更は、ブラウザのアドレスバーに反映されます。

** $location サービスとは **

- ブラウザのアドレスバー内のカレント URL へのアクセスを提供するので、
  - URL を watch したり observe することができます。
  - URL を変更することができます。
- ユーザが下記のことを行ったとき、ブラウザとの間で URL を同期します。
  - ユーザがアドレスバーに変更を加えたとき
  - 戻る・進むボタンをクリックしたとき (または履歴のリンクをクリックしたとき)
  - リンクをクリックしたとき
- URL オブジェクトをメソッド (protocol, host, port, path, search, hash) のセットとして表します。


## $location と window.location の比較

<table class="table">
<thead>

  <tr>
    <th class="empty-corner-lt"></th>
    <th>window.location</th>
    <th>$location サービス</th>
  </tr>

</thead>
<tbody>

  <tr>
    <td class="head">目的</td>
    <td>ブラウザのカレント location への読み書きアクセスを提供すること</td>
    <td>左と同じ</td>
  </tr>

  <tr>
    <td class="head">API</td>
    <td>直接変更できるプロパティを持つ「生の」オブジェクトへのアクセスを提供</td>
    <td>jQuery スタイルの getter と setter を提供</td>
  </tr>

  <tr>
    <td class="head">Angular アプリケーションのライフサイクルとの統合</td>
    <td>なし</td>
    <td>内部のライフサイクルフェーズについてすべてわかっているので、 $watch などと併せて使用可能</td>
  </tr>

  <tr>
    <td class="head">HTML5 API とシームレスに統合するか?</td>
    <td>いいえ</td>
    <td>はい (レガシーブラウザの場合はフォールバック)</td>
  </tr>

  <tr>
    <td class="head">アプリケーションが読み込また元の docroot / コンテキストを理解しているか?</td>
    <td>いいえ - window.location.path は "/docroot/actual/path" を返す</td>
    <td>はい - $location.path() は "/actual/path" を返す</td>
  </tr>

</tbody>
</table>

## どのような場合に $location を使うべきか?
アプリケーションが、カレント URL の変更に反応する必要がある場合や、
ブラウザのカレント URL を変更したい場合は常に $location を使用すべきです。

## $location がしてくれないことは?
$location はブラウザの URL が変化したときに完全なページのリロードを実行しません。
URL が変化した後にページをリロードするには、更に低レベルな API である `$window.location.href` 
を使用してください。

# API の概要

`$location` がインスタンス化されるときに提供される設定によって、 `$location` 
サービスは異なる振る舞いをすることがあります。
デフォルトの設定は多くのアプリケーションに適していますが、カスマイズした設定によって、
新たな機能を有効にすることができます。

一度 `$location` サービスがインスタンス化されると、ブラウザのカレント URL を取得または変更できる、
jQuery スタイルの getter と setter メソッドを操作することができます。

## $location サービスの設定

`$location` サービスを設定するには、 {@link api/ng.$locationProvider $locationProvider}
を取得し、次のようにしてパラメータをセットします。


- **html5Mode(mode)**: {boolean}<br />
  `true` - HTML5 モードを参照<br />
  `false` - Hashbang モードを参照<br />
  デフォルト : `false`

- **hashPrefix(prefix)**: {string}<br />
  Hashbang URL で使用するプレフィックス
  (Hashbang モードのとき、または、 HTML5 モードでレガシーブラウザのときに使用されます)<br />
  デフォルト : `'!'`

### 設定例
<pre>
$locationProvider.html5Mode(true).hashPrefix('!');
</pre>

## getter, setter メソッド

`$location` サービスは、 URL の読み取り専用の部分 (absUrl, protocol, host, port) 
に対して getter メソッドを、そして url, path, search, hash に対しては、getter / setter 
メソッドを提供します。
<pre>
// カレントパスを取得
$location.path();

// パスを変更
$location.path('/newValue')
</pre>

すべての setter メソッドは、メソッドチェーンを実現するため、同じ `$location` を返します。
たとえば、複数のセグメントを一度に変更するときは、次のように setter をつなげます。
<pre>$location.path('/newValue').search({key: value});</pre>

特別なものとして `replace` メソッドがあり、次に $location サービスがブラウザと同期するときには、
新たな履歴を作成するのではなく、最後の履歴と置き換えるように $location サービスに指示することができます。
このメソッドはリダイレクトを実装するときに便利で、 `replace` メソッドを使わなければ、
戻るボタンがうまく動作しなくなってしまいます (戻っても再度リダイレクトが働いてしまいます)。
新たなブラウザ履歴を作成せずにカレント URL を変更するには、次のように呼び出します。
<pre>
  $location.path('/someNewPath');
  $location.replace();
  // または次のようにチェーンすることもできます: $location.path('/someNewPath').replace();
</pre>

ここで、 setter はすぐには `window.location` を更新しないことに注意してください。
その代わり、 `$location` サービスは {@link api/ng.$rootScope.Scope スコープ} 
のライフサイクルを認識しており、複数の `$location` 操作を 1 つの "コミット" にまとめ、
スコープの `$digest` フェーズ中に `window.location` オブジェクトに 1 回で反映します。
$location の状態への複数の変更はブラウザに対する 1 回の変更として処理されるため、
`replace()` メソッドを 1 度だけ呼び出せば、
"コミット" 全体を、ブラウザの新たな履歴を作成するのではなく、 replace 操作にすることができます。
ブラウザが更新されれば、 $location サービスは `replace()` メソッドによってセットされたフラグをリセットし、
以後の操作は、 `replace()` が再度呼び出されない限り、ブラウザの新たな履歴を作成するようになります。

### setter と文字のエンコーディング
`$location` サービスには特殊文字を渡すことができ、 `$location` サービスはそれらの文字を
{@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986} で規定されたルールでエンコードします。
このエンコード処理は、次のメソッドにアクセスしたときに実行されます。

- `$location` の setter メソッド (`path()`, `search()`, `hash()`) に渡されたすべての値はエンコードされます。
- `path()`, `search()`, `hash()` の getter (パラメータなしのメソッド呼び出し) は、デコードされた値を返します。
- `absUrl()` メソッドを呼び出したとき、返り値はセグメントがエンコードされた完全な URL です。
- `url()` メソッドを呼び出したとき、返り値は `/path?search=a&b=c#hash` の形式の path, search, hash です。
  セグメントはやはりエンコードされます。


# Hashbang モードと HTML5 モード

`$location` サービスには、ブラウザのアドレスバーに表示される URL のフォーマットを制御する 2 
つの設定モードがあります。 1 つは **Hashbang モード** (デフォルト) で、もう 1 つは HTML5 
の {@link http://www.w3.org/TR/html5/history.html History API} をベースとする **HTML5 モード** です。
アプリケーションはどちらのモードでも同じ API を使い、 `$location` サービスは適切な URL 
セグメントとブラウザの API と連携して、ブラウザの URL の変更と履歴の管理を楽にしてくれます。

<img src="img/guide/hashbang_vs_regular_url.jpg">

<table class="table">
<thead>

  <tr>
    <th class="empty-corner-lt"></th>
    <th>Hashbang モード</th>
    <th>HTML5 モード</th>
  </tr>

</thead>
<tbody>

  <tr>
    <td class="head">設定</td>
    <td>デフォルト</td>
    <td>{ html5Mode: true }</td>
  </tr>

  <tr>
    <td class="head">URL フォーマット</td>
    <td>すべてのブラウザで Hashbang URL</td>
    <td>モダンブラウザでは標準的な URL 、レガシーブラウザでは、 Hashbang URL</td>
  </tr>

  <tr>
    <td class="head">&lt;a href=""&gt; リンクの書き換えを行うか?</td>
    <td>いいえ</td>
    <td>はい</td>
  </tr>

  <tr>
    <td class="head">サーバサイドの設定を必要とするか?</td>
    <td>いいえ</td>
    <td>はい</td>
  </tr>
</tbody>
</table>

## Hashbang モード (デフォルト)

このモードでは、すべてのブラウザで `$location` は Hashbang URL を使用します。

### 例

<pre>
it('should show example', inject(
  function($locationProvider) {
    $locationProvider.html5Mode(false);
    $locationProvider.hashPrefix = '!';
  },
  function($location) {
    // http://host.com/base/index.html#!/a を開く
    $location.absUrl() == 'http://host.com/base/index.html#!/a'
    $location.path() == '/a'

    $location.path('/foo')
    $location.absUrl() == 'http://host.com/base/index.html#!/foo'

    $location.search() == {}
    $location.search({a: 'b', c: true});
    $location.absUrl() == 'http://host.com/base/index.html#!/foo?a=b&c'

    $location.path('/new').search('x=y');
    $location.absUrl() == 'http://host.com/base/index.html#!/new?x=y'
  }
));
</pre>

### アプリケーションのクローリングについて

AJAX アプリケーションのインデックスを許可するためには、ドキュメントの head セクションに特殊な meta 
タグを追加する必要があります。
<pre><meta name="fragment" content="!" /></pre>

このようにしておくと、クローラボットは `_escaped_fragment_` 
パラメータを使用してリンクをリクエストするようになり、
サーバはクローラによるアクセスであると判断できるので、 HTML のスナップショットを返すことができます。
このテクニックに関して詳しくは、 {@link http://code.google.com/web/ajaxcrawling/docs/specification.html 
Making AJAX Applications Crawlable} を参照してください。

## HTML5 モード

HTML5 モードでは、 `$location` サービスの getter, setter は HTML5 History API 
を通してブラウザの URL アドレスを操作します。そのため、 Hashbang のようなものを使わずに、
通常の URL の path や search のセグメントを使用できます。
もしブラウザが HTML5 History API をサポートしていない場合は、 `$location` 
サービスは自動的にフォールバックして Hashbang URL を使うようになります。
このようなフォールバックがあるので、アプリケーションを表示するブラウザが 
History API をサポートしているかどうか心配する必要はなくなり、
`$location` サービスが最適な方法を自動的に選択します。

- レガシーブラウザで標準の URL を開く -> Hashbang URLにリダイレクトする
- モダンブラウザで Hashbang URL を開く -> 通常の URL に書き換える

### 例

<pre>
it('should show example', inject(
  function($locationProvider) {
    $locationProvider.html5Mode(true);
    $locationProvider.hashPrefix = '!';
  },
  function($location) {
    // HTML5 History API をサポートしているブラウザの場合:
    // http://host.com/#!/a を開くと、http://host.com/a に書き換える
    // (http://host.com/#!/a の履歴レコードを置き換える)
    $location.path() == '/a'

    $location.path('/foo');
    $location.absUrl() == 'http://host.com/foo'

    $location.search() == {}
    $location.search({a: 'b', c: true});
    $location.absUrl() == 'http://host.com/foo?a=b&c'

    $location.path('/new').search('x=y');
    $location.url() == 'new?x=y'
    $location.absUrl() == 'http://host.com/new?x=y'

    // HTML5 History API をサポートしていないブラウザの場合:
    // http://host.com/new?x=y を開くと、http://host.com/#!/new?x=y にリダイレクトする
    // (同様に、http://host.com/new?x=y 履歴レコードを置き換える)
    $location.path() == '/new'
    $location.search() == {x: 'y'}

    $location.path('/foo/bar');
    $location.path() == '/foo/bar'
    $location.url() == '/foo/bar?x=y'
    $location.absUrl() == 'http://host.com/#!/foo/bar?x=y'
  }
));
</pre>

### レガシーブラウザ向けのフォールバック

HTML5 History API をサポートしているブラウザの場合、 `$location` は HTML5 History APIを使って path 
や search を書き換えます。もし History API をブラウザがサポートしていない場合は、 `$location` 
は Hashbang URL を代わりに使います。
このようなフォールバックがあるので、アプリケーションを閲覧するブラウザが History API 
をサポートしているかを心配する必要はありません。
`$location` サービスはあなたが気づかないうちにこのようなフォールバックを行います。

### HTML リンクの書き換え

HTML5 History API モードを使用するときは、本来はブラウザによって異なるリンクを使用しなければなりませんが、
`<a href="/some?foo=bar">link</a>` のような通常の URL リンクを指定するだけで構いません。

ユーザがこのリンクをクリックすると、

- レガシーブラウザでは、 `/index.html#!/some?foo=bar` に URL が変化し、
- モダンブラウザでは、 `/some?foo=bar` に URL が変化します。


下記のような場合は、リンクは書き換えられません。
その代わり、ブラウザは元のリンク先のページすべてをリロードします。

- `target` 属性を含むリンク<br>
  例: `<a href="/ext/link?a=b" target="_self">link</a>`
- 別のドメインへの絶対リンク<br>
  例: `<a href="http://angularjs.org/">link</a>`
- base が定義されているとき、別の base パスへ誘導する、 '/' から始まるリンク<br>
  例: `<a href="/not-my-base/link">link</a>`


### サーバサイド

このモードを使用する場合は、サーバサイドで URL を書き換える必要があります。
基本的にすべてのリンクをアプリケーションのエントリポイント (たとえば index.html) 
に書き換えなければなりません。

### アプリケーションのクローリングについて

AJAX アプリケーションを Web クローラにインデックスしてもらいたい場合は、下記の meta 
タグをドキュメントの head セクションに追加する必要があります。
<pre><meta name="fragment" content="!" /></pre>

このように記述しておくと、クローラは、空の `_escaped_fragment_` 
パラメータを使用してリンクをリクエストするようになり、
サーバはクローラによるアクセスであると判断できるので、 HTML のスナップショットを返すことができます。
このテクニックに関して詳しくは、 {@link http://code.google.com/web/ajaxcrawling/docs/specification.html 
Making AJAX Applications Crawlable} を参照してください。

### 相対リンク

すべての相対リンク・画像・スクリプトなどの URL は必ずチェックするようにしてください。
相対 URL は、ドキュメントの初期の絶対 URL を使って絶対 URL に変換されますが、
多くの場合、アプリケーションのルートと、相対リンク・画像・スクリプトなどの base URL は異なります。
このような理由から、相対リンク・画像・スクリプトなどの URL については、
メインの HTML ファイルの head で URL base を指定するか (`<base href="/my-base">`) 、
すべて絶対 URL (`/` で始まるもの) を使用するようにしなければなりません。

強く推奨される方法は、サーバのドキュメントルートで、 History API を有効にした Angular 
アプリケーションを動作させることで、こうすればすべての相対リンクに関する問題は解決されます。

### 異なるブラウザ間でリンクを送信する

HTML5 モードでは URL を書き換えることができるため、ユーザはレガシーブラウザで通常の URL リンクを開くことも、
モダンブラウザで Hashbang URL リンクを開くこともできます。

- モダンブラウザでは、 Hashbang URL は通常の URL に書き換えられます。
- レガシーブラウザでは、通常の URL は Hashbang URL にリダイレクトされます。

### 例

下記の例では、 2 つの `$location` サービスのインスタンスがあり、どちらも **HTML5 モード** に設定されていますが、
別々のブラウザで動作しており、その違いを確認することができます。
2 つの `$location` サービスはフェイクのブラウザにつながっています。
それぞれのサービスへの入力はブラウザのアドレスバーを表しています。

1 つ目のブラウザに Hashbang URL を入力した場合 (通常の URL を入力した場合も同様に) 、
通常の URL と Hashbang URL の変換は初期の URL のパース中 (= ページのリロード時) にしか実行されないので、
通常の URL への書き換えや Hashbang URL へのリダイレクトは行われないことに注意してください。

この例では、 `<base href="/base/index.html" />` を使用します。
<doc:example>
<doc:source source="false">

<div ng-non-bindable class="html5-hashbang-example">
  <div id="html5-mode" ng-controller="Html5Cntl">
    <h3>Browser with History API</h3>
    <div ng-address-bar browser="html5"></div><br><br>
    $location.protocol() = {{$location.protocol()}}<br>
    $location.host() = {{$location.host()}}<br>
    $location.port() = {{$location.port()}}<br>
    $location.path() = {{$location.path()}}<br>
    $location.search() = {{$location.search()}}<br>
    $location.hash() = {{$location.hash()}}<br>
    <a href="http://www.host.com/base/first?a=b">/base/first?a=b</a> |
    <a href="http://www.host.com/base/sec/ond?flag#hash">sec/ond?flag#hash</a> |
    <a href="/other-base/another?search">external</a>
  </div>

  <div id="hashbang-mode" ng-controller="HashbangCntl">
    <h3>Browser without History API</h3>
    <div ng-address-bar browser="hashbang"></div><br><br>
    $location.protocol() = {{$location.protocol()}}<br>
    $location.host() = {{$location.host()}}<br>
    $location.port() = {{$location.port()}}<br>
    $location.path() = {{$location.path()}}<br>
    $location.search() = {{$location.search()}}<br>
    $location.hash() = {{$location.hash()}}<br>
    <a href="http://www.host.com/base/first?a=b">/base/first?a=b</a> |
    <a href="http://www.host.com/base/sec/ond?flag#hash">sec/ond?flag#hash</a> |
    <a href="/other-base/another?search">external</a>
  </div>
</div>

<script>
  function FakeBrowser(initUrl, baseHref) {
    this.onUrlChange = function(fn) {
      this.urlChange = fn;
    };

    this.url = function() {
      return initUrl;
    };

    this.defer = function(fn, delay) {
      setTimeout(function() { fn(); }, delay || 0);
    };

    this.baseHref = function() {
      return baseHref;
    };

    this.notifyWhenOutstandingRequests = angular.noop;
  }

  var browsers = {
    html5: new FakeBrowser('http://www.host.com/base/path?a=b#h', '/base/index.html'),
    hashbang: new FakeBrowser('http://www.host.com/base/index.html#!/path?a=b#h', '/base/index.html')
  };

  function Html5Cntl($scope, $location) {
    $scope.$location = $location;
  }

  function HashbangCntl($scope, $location) {
    $scope.$location = $location;
  }

  function initEnv(name) {
    var root = angular.element(document.getElementById(name + '-mode'));
    angular.bootstrap(root, [function($compileProvider, $locationProvider, $provide){
      $locationProvider.html5Mode(true).hashPrefix('!');

      $provide.value('$browser', browsers[name]);
      $provide.value('$document', root);
      $provide.value('$sniffer', {history: name == 'html5'});

      $compileProvider.directive('ngAddressBar', function() {
        return function(scope, elm, attrs) {
          var browser = browsers[attrs.browser],
              input = angular.element('<input type="text">').val(browser.url()),
              delay;

          input.bind('keypress keyup keydown', function() {
            if (!delay) {
              delay = setTimeout(fireUrlChange, 250);
            }
          });

          browser.url = function(url) {
            return input.val(url);
          };

          elm.append('Address: ').append(input);

          function fireUrlChange() {
            delay = null;
            browser.urlChange(input.val());
          }
        };
      });
    }]);
    root.bind('click', function(e) {
      e.stopPropagation();
    });
  }

  initEnv('html5');
  initEnv('hashbang');
</script>

</doc:source>
</doc:example>


# 注意点

## ページをリロードする遷移

`$location` サービスを使うと、 URL を変更することしかできず、ページをリロードすることはできません。
URL を変更してページをリロードしなければならない場合や、別のページに遷移しなければならない場合は、
低レベル API である、{@link api/ng.$window $window.location.href} を使用してください。

## スコープのライフサイクル外での $location の使用

`$location` は Angular の {@link api/ng.$rootScope.Scope スコープ} ライフサイクルを理解しています。
ブラウザの URL が変化すると、 `$location` が更新され、 `$apply` が呼び出され、すべての $watcher / 
$observer は通知を受けます。
`$digest` フェーズ中に `$location` を変更することは、何も問題ありません。
`$location` はこの変更をブラウザに反映し、すべての $watcher / $observer に通知します。
しかし、Angular の外から (たとえば、 DOM イベントやテストのときに) `$location` を変更するときは、
変更を反映するために `$apply` を呼びださなければなりません。

## $location.path() と プレフィックス (! や /)

path は必ずスラッシュ (`/`) で始まらなければならないので、 `$location.path()` の setter は、
path の先頭にスラッシュがなければ追加するようになっています。

Hashbang モードにおける `!` プレフィックスは `$location.path()` に含まれないことに注意してください。
`!` プレフィックスは実際の hashPrefix です。


# $location サービスを使用するテスト

テストにおいて、 `$location` サービスを使用する場合は、 Angular の {@link api/ng.$rootScope.Scope スコープ}
ライフサイクルの外から使用することになります。したがって、テストコードから `scope.$apply()` 
を呼び出さなければなりません。

<pre>
describe('serviceUnderTest', function() {
  beforeEach(module(function($provide) {
    $provide.factory('serviceUnderTest', function($location){
      // サービスのコード...
    });
  });

  it('should...', inject(function($location, $rootScope, serviceUnderTest) {
    $location.path('/new/path');
    $rootScope.$apply();

    // サービスをテストするコード...

  }));
});
</pre>


# 以前のバージョンの AngularJS からの移行

以前のバージョンの Angular では、 `$location` は path と search メソッドを処理するために、
`hashPath` または `hashSearch` を使用していました。現在のバージョンでは、 `$location` 
サービスが path と search メソッドを処理し、取得した情報を使用して、必要な場合のみ
`http://server.com/#!/path?search=a` のような Hashbang URL を組み立てます。

## コードへの変更

<table class="table">
  <thead>
    <tr class="head">
      <th>アプリケーション内の遷移</th>
      <th>変更方法</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>$location.href = value<br />$location.hash = value<br />$location.update(value)<br
/>$location.updateHash(value)</td>
      <td>$location.path(path).search(search)</td>
    </tr>

    <tr>
      <td>$location.hashPath = path</td>
      <td>$location.path(path)</td>
    </tr>

    <tr>
      <td>$location.hashSearch = search</td>
      <td>$location.search(search)</td>
    </tr>

    <tr class="head">
      <th>アプリケーション外への遷移</th>
      <th>低レベル API を使用する</th>
    </tr>

    <tr>
      <td>$location.href = value<br />$location.update(value)</td>
      <td>$window.location.href = value</td>
    </tr>

    <tr>
      <td>$location[protocol | host | port | path | search]</td>
      <td>$window.location[protocol | host | port | path | search]</td>
    </tr>
	
    <tr class="head">
      <th>読み取りアクセス</th>
      <th>変更方法</th>
    </tr>

    <tr>
      <td>$location.hashPath</td>
      <td>$location.path()</td>
    </tr>

    <tr>
      <td>$location.hashSearch</td>
      <td>$location.search()</td>
    </tr>

    <tr>
      <td>$location.href<br />$location.protocol<br />$location.host<br />$location.port<br
/>$location.hash</td>
      <td>$location.absUrl()<br />$location.protocol()<br />$location.host()<br />$location.port()<br
/>$location.path() + $location.search()</td>
    </tr>

    <tr>
      <td>$location.path<br />$location.search</td>
      <td>$window.location.path<br />$window.location.search</td>
    </tr>
  </tbody>
</table>

## $location への双方向バインディング

Angular のコンパイラはいまのところ、メソッドに対する双方向バインディングをサポートしていません
({@link https://github.com/angular/angular.js/issues/404 issue} を参照)。
$location オブジェクトへの双方向バインディングが必要な場合 (入力フィールドで 
{@link api/ng.directive:input.text ngModel} ディレクティブを使用する場合など) は、
追加でモデルのプロパティ (locationPath など) を指定し、 $location の更新を双方向に通知する 
2 つの watcher をセットしなければなりません。
下記に例を示します。

<pre>
<!-- html -->
<input type="text" ng-model="locationPath" />
</pre>
<pre>
// js - controller
$scope.$watch('locationPath', function(path) {
  $location.path(path);
});

$scope.$watch('$location.path()', function(path) {
  scope.locationPath = path;
});
</pre>


# 関連 API

* {@link api/ng.$location $location API}



